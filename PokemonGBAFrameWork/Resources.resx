<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="mscorlib" name="mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="ASMMugshotsFR" type="System.Byte[], mscorlib">
    <value>
        LyoNCk5vdGU6IGJvdGggaW1hZ2UgYW5kIHBhbGV0dGUgc2hvdWxkIGJlIExaNzcgY29tcHJlc3NlZCEN
        ClRhYmxlIGZvcm1hdDogW2ltYWdlIHBvaW50ZXJdW3BhbCBwb2ludGVyXS4uLi4uLi4uLi4NCiovDQou
        ZXF1aXYgdGFibGVfbG9jYXRpb24sIDB4ODkwMDAwMA0KLnRodW1iDQpwdXNoIHtyNC1yNSwgbHJ9DQpz
        dWIgc3AsIHNwLCAjMHgxOA0KbGRyIHIwLCA9MHgyMDM3MEMwDQpsZHJoIHIwLCBbcjAsICMyXQ0KbW92
        IHIxLCAjMA0KbW92IHIyLCAjMHgxNA0KbXVsIHIyLCByMA0KbW92IHIzLCAjNA0KbW92IHIwLCAjMTAN
        CnN0ciByMCwgW3NwXQ0Kc3RyIHIwLCBbc3AsICM0XQ0KbW92IHIwLCAjMHhEDQpzdHIgcjAsIFtzcCwg
        IzhdDQptb3YgcjAsICMweDQwDQpzdHIgcjAsIFtzcCwgIzB4Q10NCmFkZCByMCwgc3AsICMweDEwDQps
        ZHIgcjQsID0weDgxMEZFNTENCmJsIGJ4X3I0DQphZGQgcjAsIHNwLCAjMHgxMA0KbGRyIHI0LCA9MHg4
        MDAzQ0U1DQpibCBieF9yNA0KbGRyIHI0LCA9MHgyMDM5OTkwDQpzdHJiIHIwLCBbcjRdDQpsZHIgcjQs
        ID0weDgwMDNGQTENCmJsIGJ4X3I0DQpsZHIgcjAsID0weDIwMzcwQzANCmxkcmggcjAsIFtyMF0NCmxk
        ciByMSwgPXRhYmxlX2xvY2F0aW9uDQpsc2wgcjAsIHIwLCAjMw0KYWRkIHIwLCByMCwgcjENCmxkciBy
        NSwgW3IwLCAjNF0NCmxkciByMCwgW3IwXQ0KbGRyIHIxLCA9MHg2MDA4ODAwDQpzd2kgMHgxMg0KbW92
        IHIwLCByNQ0KbW92IHIxLCAjMHhkMA0KbW92IHIyLCAjMHgyMA0KbGRyIHI0LCA9MHg4MDcwM0E5DQpi
        bCBieF9yNA0KbW92IHIwLCAjMA0KbGRyIHI0LCA9MHg4MDAyMEJEDQpibCBieF9yNA0KYWRkIHNwLCBz
        cCwgIzB4MTgNCnBvcCB7cjQtcjUsIHBjfQ0KDQpieF9yNDogYnggcjQ=
</value>
  </data>
  <data name="ASMPokemonInCapturable" xml:space="preserve">
    <value>.text
.align 2
.thumb
.thumb_func

main:
 ldr r0, =(0x2022B4C)
 ldr r1, [r0]
 ldr r2, .VAR
 ldrb r2, [r2]
 cmp r2, #0x1
 beq uncatchable
 ldr r0, = (0x802D490 +1)
 bx r0

uncatchable:
 ldr r0, = (0x802D460 +1)
 bx r0
 
 

.align 2
.VAR:
 .word 0x020270B8 + (0xVARIABLE * 2)</value>
  </data>
  <data name="ASMShinyzer" xml:space="preserve">
    <value>.text
.align 2
.thumb
.thumb_func

shiny_hack_main:
 lsr r0, r4, #0x18
 cmp r0, #0x3
 bne return
 ldr r0, .SHINY_COUNTER
 ldrb r0, [r0]
 cmp r0, #0x0
 bne shiny_hack

return:
 bx lr

shiny_hack:
 push {r2-r5, lr}
 sub r3, r0, #0x1
 ldr r0, .SHINY_COUNTER
 strb r3, [r0]
 ldrb r4, [r0, #0x1]
 cmp r4, #0x0
 bne is_trainer
 add r4, r1, #0x0

no_trainer:
 ldr r2, .RANDOM
 bl branch_r2
 mov r3, #0x7
 and r0, r3
 add r3, r0, #0x0
 ldr r2, .RANDOM
 bl branch_r2
 lsl r5, r0, #0x10
 orr r5, r0
 eor r5, r3
 eor r5, r4
 push {r4-r6}
 lsr r1, r5, #0x10
 lsl r0, r5, #0x10
 mvn r3, r3
 lsr r3, r3, #0x10
 ldr r4, .RND_MULTIPLIER
 ldr r5, .RND_INCREMENT

rnd_loop:
 add r6, r0, #0x0
 mul r6, r4
 add r6, r5
 lsr r2, r6, #0x10
 cmp r2, r1
 beq rnd_end
 add r0, #0x1
 sub r3, #0x1
 cmp r3, #0x0
 bne rnd_loop
 b not_found
 
rnd_end:
 ldr r2, .RND_ADDRESS
 str r6, [r2]
 pop {r1, r5-r6}
 str r5, [r7]

shiny_ret:
 pop {r2-r5, pc}

not_found:
 pop {r4-r6}
 b no_trainer

is_trainer:
 mov r5, #0x1
 lsl r5, r3
 and r4, r5
 cmp r4, #0x0
 beq trainer_ret
 ldr r1, [r7]

trainer_ret:
 b shiny_ret

branch_r2:
 bx r2
 
.align 2
.RND_MULTIPLIER:
 .word 0x41C64E6D
.RND_INCREMENT:
 .word 0x00006073
.RND_ADDRESS:
 .word 0x03005D80
.SHINY_COUNTER:
 .word 0x020375DE
.RANDOM:
 .word 0x0806F5CC|1
 </value>
  </data>
</root>